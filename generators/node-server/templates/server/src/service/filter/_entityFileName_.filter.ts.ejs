import { ApiProperty } from '@nestjs/swagger';
import { IsOptional, IsString, IsNumber, IsEnum, IsDate, IsBoolean } from 'class-validator';
import { Type } from 'class-transformer';

 <%_
const uniqueEnums = {};
const fieldsWithoutId = [];

for (idx in fields) {
    if (fields[idx].fieldIsEnum && (
            !uniqueEnums[fields[idx].fieldType] || (uniqueEnums[fields[idx].fieldType] && fields[idx].fieldValues.length !== 0))) {
        uniqueEnums[fields[idx].fieldType] = this._.kebabCase(fields[idx].fieldType);
    }
    if (fields[idx].fieldName !== 'id') {
        fieldsWithoutId.push(fields[idx]);
    }
}
_%>

<%_ Object.keys(uniqueEnums).forEach(function(enumClass) { _%>
    import { <%= enumClass %> } from '../../domain/enumeration/<%= uniqueEnums[enumClass] %>';
<%_ }); _%>

export enum FilterOperator {
AND = 'AND',
OR = 'OR'
}

export class <%= entityClass %>Filter {
@ApiProperty({ required: false, enum: FilterOperator, default: FilterOperator.AND })
@IsOptional()
@IsEnum(FilterOperator)
operator?: FilterOperator = FilterOperator.AND;

@ApiProperty({ required: false })
@IsOptional()
@IsString()
id?: string;

<%_ for (const field of fieldsWithoutId) {
    const fieldName = field.fieldName;

if (field.fieldType === 'number' || field.fieldType === 'integer' || field.fieldType === 'float') { _%>
    @ApiProperty({ required: false, description: 'Filter by exact <%= fieldName %>' })
    @IsOptional()
    @IsNumber()
    <%= fieldName %>?: number;

<%_ } else if (field.fieldTypeLocalDate) { _%>
    @ApiProperty({ required: false, description: 'Filter by exact <%= fieldName %>' })
    @IsOptional()
    @Type(() => Date)
    @IsDate()
    <%= fieldName %>?: Date;

    @ApiProperty({ required: false, description: 'Filter <%= fieldName %> after date' })
    @IsOptional()
    @Type(() => Date)
    @IsDate()
    <%= fieldName %>After?: Date;

    @ApiProperty({ required: false, description: 'Filter <%= fieldName %> before date' })
    @IsOptional()
    @Type(() => Date)
    @IsDate()
    <%= fieldName %>Before?: Date;

<%_ } else if (field.fieldIsEnum) { _%>
    @ApiProperty({ required: false, enum: <%= field.fieldType %>, description: 'Filter by <%= fieldName %>' })
    @IsOptional()
    @IsEnum(<%= field.fieldType %>)
    <%= fieldName %>?: <%= field.fieldType %>;

    @ApiProperty({ required: false, isArray: true, enum: <%= field.fieldType %>, description: 'Filter <%= fieldName %> in values' })
    @IsOptional()
    @IsEnum(<%= field.fieldType %>, { each: true })
    <%= fieldName %>In?: <%= field.fieldType %>[];

<%_ } else if (field.fieldTypeBoolean) { _%>
    @ApiProperty({ required: false, description: 'Filter by <%= fieldName %>' })
    @IsOptional()
    @IsBoolean()
    <%= fieldName %>?: boolean;

<%_ } else if (field.fieldType === 'object') { _%>
    @ApiProperty({ required: false, description: 'Generic object filter for <%= fieldName %>' })
    @IsOptional()
    <%= fieldName %>?: any;

<%_ } else { _%>
    @ApiProperty({ required: false, description: 'Filter by exact <%= fieldName %>' })
    @IsOptional()
    @IsString()
    <%= fieldName %>?: string;

    @ApiProperty({ required: false, description: 'Filter <%= fieldName %> contains' })
    @IsOptional()
    @IsString()
    <%= fieldName %>Contains?: string;

<%_ }
} _%>

static apply(query: any): any {
if (!query) return {};

const { operator, ...filters } = query;
const filterOperator = operator || FilterOperator.AND;
const conditions = [];

for (const [key, value] of Object.entries(filters)) {
if (!value) continue;

const baseField = key.replace(/Contains|In|After|Before/g, '');
let condition = {};

if (key.endsWith('Contains')) {
condition[baseField] = { $like: `%${value}%` };
} else if (key.endsWith('In')) {
condition[baseField] = { $in: value };
} else if (key.endsWith('After')) {
condition[baseField] = { $gt: value };
} else if (key.endsWith('Before')) {
condition[baseField] = { $lt: value };
} else {
condition[baseField] = value;
}

conditions.push(condition);
}

if (conditions.length === 0) return {};
if (conditions.length === 1) return conditions[0];

return filterOperator === FilterOperator.AND
? { $and: conditions }
: { $or: conditions };
}
}
